QNet
~~~~
QNet est un nième client pour <Mtp> Chat! écrit en Qt (enfin c'est le
premier en Qt et le nième en général... enfin je me comprends)
Version actuelle : 0.47-cvs


Compiler
~~~~~~~~
pré-requis : 
- libqt3 + headers 
- qmake

Les versions de Qt testées sont les suivantes : Qt 3.0.5 (marche à peu près convenablement), Qt >= 3.1 (pas de problème particulier)
Pour les autres versions : je n'ai pas la possibilité de tester dans ces conditions (non je n'ai pas 50 versions de Qt installées).
Si le problème que vous constatez n'est pas reproductible sur l'une des plateformes précédemment citées, JE NE POURRAI RIEN FAIRE
Si quelqu'un me propose un patch spécifique pour contourner ce genre de problème je l'accepterai avec joie. Sinon, tant pis.

pour la compilation proprement dite, il faut positionner les variables
d'environnements QTDIR et QMAKESPEC
(ex : 
    "export QTDIR=/usr/lib/qt3" (mandrake) ou "export QTDIR=/usr/share/qt" voire "export QTDIR=/usr/share/qt3" (debian)
    "export QMAKESPEC=linux-g++"
)

puis un "qmake && make" devrait suffire... (là un café s'impose, en
plus ça compile en mode debug)

J'insiste sur le fait qu'il faut positionner les variables *avant* le
qmake, sinon make vous insulte. Dans ce cas, outre le fait que ce
n'est pas bien de ne pas lire le README, il faut effacer le Makefile
de *chaque* répertoire avant de recommencer (bien fait pour vous)

Après ça, si tout s'est bien passé (mouahaha je n'y crois pas un instant) le joli exécutable se trouve dans bin/

Reste à copier le qnetrc en ~/.qnetrc et à lancer le monstre.
update: dans l'état actuel des choses, il vous faudra éditer le .qnetrc et remplacer les lignes /path/to/*.so par les chemins absolus menant à chacun des plugins.
On essaiera de faire un peu mieux plus tard ;-)

Sigma.

Commentaires d'utilisateurs
~~~~~~~~~~~~~~~~~~~~~~~~~~~
"<Kartoch> Lofic: très simple, il te suffit de peindre une fenetre de scroll et 5 boutons sur un parpaing... même ergonomie que le qnet original"

Fonctionnalités
~~~~~~~~~~~~~~~
Toutes les fonctionnalités ou presque sont liées à la notion de filtre (entrée/sortie). Les filtres ne sont pas encore directement accessibles à l'utilisateurs pour configuration dynamique, mais c'est prévu ;-)

Exemples de fonctionnalités :
- multi-sessions (seul le protocole "Mtp" est supporté pour l'heure)
- coloration/formatage de la sortie
- support des urls, configuration des applications à lancer (attention aux trous de sécurité, aucun contrôle n'est effectué au niveau des urls)
- onglets de tell / wall
- fenêtres des utilisateurs présents
- historique des commandes entrées au clavier (Shift + haut/bas)
- zone d'entrée multilignes (Ctrl-Entrée pour aller à la ligne, flèches pour naviguer)
- redimensionnage des messages trop longs (avec respect des commandes préfixes : tell, senddata ...)
- mode fortune (indispensable)
- complétion des logins (Tab après au moins une lettre de login)
- support dessin (expérimental -- norme à définir avec les autres implémenteurs)
- contrôle distant (en cours, utilité indéniable ;-))
- équivalent du kaware (apparition en bas de l'écran d'un message contenant le login, ou d'un message de tell)


Précisions sur les filtres
~~~~~~~~~~~~~~~~~~~~~~~~~~
Les versions antérieures à la 0.47 intègrent les filtres dans le code : outre le fait que ceci est Mal(tm) ca vous empêche de les configurer, donc la question est réglée.
Bon maintenant, suite à des demandes répétées de nombreux fans (assorties de menaces d'ailleurs) les filtres sont déportés dans le .qnetrc, ce qui est Bien(tm). A l'heure où j'écris (Vendredi 9 Mai, 10h, tout est calme), la configuration a l'intérieur du client n'est pas encore possible, mais nos meilleurs techniciens y travaillent jour et nuit. Donc, si vous voulez vous lancer dans l'écriture d'un filtre, il vous faudra :
- maîtriser la syntaxe obscure desdits filtres
- les convertir en format xml (ce qui n'est pas nécessairement la partie la plus facile)

On va s'occuper de la première partie.
Au commencement il y eut le filtre (Filter) dans toute sa splendeur de généralité. Malheureusement il était fort virtuel (virtual) car ne sachant guère à quoi on allait l'employer, il engendra donc 5 fils :

- GlobalFilter l'aîné, qui a le premier un droit de regard sur tout ce qui est émis par le serveur

- BlockFilter le second, qui a la charge fort peu enviable de reconnaître des blocs spécifiques dans le bordel infâme qu'est votre session de chat.

- LineFilter, dont la tache est d'agir sur les éléments plus simples que sont les lignes de texte.

- ItemFilter, qui essaie de ramasser par ci, par là quelques éléments caractéristiques 

- InputFilter, qui lui n'agit pas sur ce qui arrive dans le client, mais sur ce qui en sort, nous reviendrons sur son rôle ultérieurement.

Il existe une hiérarchie naturelle entre les 4 premiers : chacun peut autoriser ou non le suivant à agir, et un filtre ne peut participer au repas que lorsque son supérieur a fini de manger. Oui je sais, c'est affreux ce que je dis, moyenageux et tout, mais ca simplifie la vie :-).
InputFilter quant à lui, seul de sa caste, il n'a pas ce genre de soucis.

Attardons nous un instant sur l'intération entre filtres et plugins. Pour faire simple : les plugins fournissent des outils aux filtres, et c'est tout. Un plugin peut-être chargé ou pas, si il n'est pas utilisé par un filtre, cela revient au même. Inversement, si un filtre fait appel à un plugin inexistant, le tout fonctionne forcément moins bien. Pour le moment il n'existe pas de solution permettant de conditionner un filtre par l'existence d'un plugin, ca viendra plus tard.

Maintenant que j'ai dessiné le contexte, un exemple simplifié (hourras dans la foule)
<aboutme>
  <result>\1\&lt;font color=red>\2\\3\\4\\5\&lt;/font>
:splash:spl:\2\\3\\4\</result>
  <regexp>(:\w+:\w+:)?(&lt;.*>)?(\d{2}:\d{2}:\d{2} )?(&amp;lt .*\login\[^&lt;]*)(&lt;.*>)?</regexp>
</aboutme>

Là je sens comme un silence gêné, non? bon on va détailler un peu plus. Traduit du xml en bonnes expressions régulières ca donne :
regexp : (:\w+:\w+:)?(<.*>)?(\d{2}:\d{2}:\d{2} )?(&lt .*\login\[^<]*)(<.*>)?
result : \1\<font color=red>\2\\3\\4\\5\</font>
	 :splash:spl:\2\\3\\4\

Toujours pas? ok
globalement la regexp match tout ce qui peut venir du serveur et qui comporte la valeur \login\ dans la phrase principale (comprendre tout ce qui vient VRAIMENT du serveur, et pas de ce qu'on a pu y ajouter dans les étages de filtres qui précèdent)
\login\ est une variable qui est initialisée auparavant (vous n'avez pas besoin de vous en préoccuper) pour matcher votre login, qu'il soit tout en majuscules, en minuscules ou combinaison exotique des deux.

result se découpe en 2 parties: la première est transmise au plugin de destination de la ligne avant qu'elle traverse notre filtre (voir le "(:\w+:\w+:)?" qui est appelé grace à "\1\") et colorie en rouge toute la ligne.
la deuxième partie est adressée spécifiquement au plugin qui exporte le type "splash" et a pour effet de lui faire afficher une partie de la ligne.

Voilà, simple non?
Ah oui comme vous n'aurez pas manqué de le remarquer, les lignes du serveur arrivent sous une forme un peu altérée : les "<" sont convertis en "&lt " etc.

Plugins
~~~~~~~
Les plugins fournis avec l'engin sont les suivants:

- affect : permet l'affectation d'une variable dans un filtre

- browser : affichage dans une frame de texte

- drawing : supporte le channel Dessin propre à <Mtp> Chat !

- emit : emet un message (auto-reply, etc.)

- id : fenetre expérimentale pour le finger ;-)

- splash : popup dans un coin de l'écran

- tell : onglet de discussion privée

- ptime : gestion de l'heure et de la date (timestamp par exemple)
  ex : :ptime:ok:HOUR<-[time]hh:mm:ss
  ex : :ptime:ok:DAY<-[date]dd:MM:yy

- pformat : formatage de chaines de caractères
  ex : :pformat:ok:PLOP<-"%1",("\Login\":-8)
  met dans la variable PLOP votre login formaté sur 8 caractères avec alignement à gauche
