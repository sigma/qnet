/* -*- buffer-read-only: t -*- vi: set ro: */
/* ----------------------------------------------------------------------------
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 1.3.21
 * 
 * This file is not intended to be easily readable and contains a number of 
 * coding conventions designed to improve portability and efficiency. Do not make
 * changes to this file unless you know what you are doing--modify the SWIG 
 * interface file instead. 
 * ----------------------------------------------------------------------------- */

/* Implementation : GUILE */

extern "C" {

extern void
SWIG_init (void)
;

}

#ifdef __cplusplus
template<class T> class SwigValueWrapper {
    T *tt;
public:
    SwigValueWrapper() : tt(0) { }
    SwigValueWrapper(const SwigValueWrapper<T>& rhs) : tt(new T(*rhs.tt)) { }
    SwigValueWrapper(const T& t) : tt(new T(t)) { }
    ~SwigValueWrapper() { delete tt; } 
    SwigValueWrapper& operator=(const T& t) { delete tt; tt = new T(t); return *this; }
    operator T&() const { return *tt; }
    T *operator&() { return tt; }
private:
    SwigValueWrapper& operator=(const SwigValueWrapper<T>& rhs);
};                                                    
#endif

/* -*- c -*-
 * -----------------------------------------------------------------------
 * Lib/guile/guile_gh_run.swg
 *
 * Guile GH runtime file
 * Copyright (C) 2000 Matthias Koeppe
 * ----------------------------------------------------------------------- */

#include "guile/gh.h"
#include <stdio.h>
#include <string.h>
#include <stdlib.h>

#ifdef __cplusplus
extern "C" {
#endif

#define SWIG_malloc(size) \
  SCM_MUST_MALLOC(size)
#define SWIG_free(mem) \
  scm_must_free(mem)
#define SWIG_ConvertPtr(s, result, type, flags) \
  SWIG_Guile_GetPtr(s, result, type)
#define SWIG_MustGetPtr(s, type, argnum, flags) \
  SWIG_Guile_MustGetPtr(s, type, argnum, FUNC_NAME)
#define SWIG_NewPointerObj(ptr, type, owner) \
  SWIG_Guile_MakePtr((void*)ptr, type)

/* Ignore object-ownership changes in gh mode */
#define SWIG_Guile_MarkPointerNoncollectable(s) (s)
#define SWIG_Guile_MarkPointerDestroyed(s) (s)
  
#define SWIG_contract_assert(expr, msg)				\
  if (!(expr))							\
    scm_error(gh_symbol2scm("swig-contract-assertion-failed"),	\
	      (char *) FUNC_NAME, (char *) msg,			\
	      SCM_EOL, SCM_BOOL_F); else

#if defined(SWIG_NOINCLUDE)
#	define SWIGSTATIC
#elif defined(SWIG_GLOBAL)
#	define SWIGSTATIC
#else
#	define SWIGSTATIC static
#endif

#define GH_NOT_PASSED    SCM_UNDEFINED
#define GH_UNSPECIFIED   SCM_UNSPECIFIED

#define SWIG_APPEND_VALUE(object)						\
    if (gswig_result == GH_UNSPECIFIED)						\
        gswig_result = object;							\
    else {									\
        if (!gswig_list_p) {							\
	    gswig_list_p = 1;							\
	    gswig_result = gh_list(gswig_result, object, GH_NOT_PASSED);	\
        }									\
        else									\
            gswig_result = gh_append2(gswig_result,				\
                                      gh_list(object, GH_NOT_PASSED));		\
    }

#define GUILE_APPEND_RESULT SWIG_APPEND_VALUE
  
/* scm_values was implemented on C level in 1.4.1, and the prototype
   is not included in libguile.h, so play safe and lookup `values'... */
#define GUILE_MAYBE_VALUES						\
    if (gswig_list_p)							\
        gswig_result = gh_apply(gh_lookup("values"), gswig_result);
    
#define GUILE_MAYBE_VECTOR				\
    if (gswig_list_p)					\
        gswig_result = gh_list_to_vector(gswig_result);

static char *
SWIG_scm2str (SCM s)
{
  return gh_scm2newstr (s, NULL);
}

#define GSWIG_scm2str SWIG_scm2str

/* SCM_CHAR and SCM_CHARP were introduced in Guile 1.4; the following is for
   1.3.4 compatibility. */
#ifndef SCM_CHAR
#  define SCM_CHAR SCM_ICHR
#endif
#ifndef SCM_CHARP
#  define SCM_CHARP SCM_ICHRP
#endif

/* This function replaces gh_scm2char, which is broken in Guile 1.4 */
static char
GSWIG_scm2char (SCM s)
{
  if (SCM_CHARP(s)) return SCM_CHAR(s);
  scm_wrong_type_arg(NULL, 0, s);
}
#define gh_scm2char GSWIG_scm2char

/* More 1.3.4 compatibility */
#ifndef SCM_INPUT_PORT_P
#  define SCM_INPUT_PORT_P SCM_INPORTP
#  define SCM_OUTPUT_PORT_P SCM_OUTPORTP
#endif

/* Type system */

typedef void *(*swig_converter_func)(void *);
typedef struct swig_type_info *(*swig_dycast_func)(void **);

typedef struct SwigPtrType SwigPtrType;

typedef struct swig_type_info {
  const char  *name;
  swig_converter_func converter;
  const char  *str;
  void        *clientdata;
  size_t tag;
  swig_dycast_func        dcast;
} swig_type_info;

SWIGSTATIC void
SWIG_Guile_RegisterTypes (swig_type_info **table,
			  swig_type_info **init);

/* Register a new type-mapping with the type-checker.  origtype is the
   original datatype and newtype is an equivalent type.  cast is optional
   pointer to a function to cast pointer values between types (this is
   typically used to cast pointers from derived classes to base classes in
   C++).  */

SWIGSTATIC void
SWIG_RegisterMapping (const char *origtype, const char *newtype,
                      swig_converter_func cast);


/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGSTATIC swig_type_info * 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr);

/* Register SWIG smobs with Guile.  */
SWIGSTATIC void
SWIG_Guile_Init();

/* Initialization function for this SWIG module; actually renamed by a
   #define */
/* extern void SWIG_init(); */

/* Get a pointer value from a smob.  If there is a type-mismatch,
   return nonzero; on success, return 0.  */
SWIGSTATIC int
SWIG_Guile_GetPtr (SCM s, void **result, swig_type_info *type);

/* Get a pointer value from a smob.  If there is a type-mismatch,
   signal a wrong-type-arg error for the given argument number. */
SWIGSTATIC void *
SWIG_Guile_MustGetPtr (SCM s, swig_type_info *type,
		       int argnum, const char *func_name);

/* Make a smob from a pointer and typeinfo.  */
SWIGSTATIC SCM
SWIG_Guile_MakePtr (void *ptr, swig_type_info *type);

/* Get arguments from an argument list */
SWIGSTATIC int
SWIG_Guile_GetArgs (SCM *dest, SCM rest,
		    int reqargs, int optargs,
		    const char *procname);

typedef SCM (*swig_guile_proc)();

#ifdef __cplusplus
}
#endif

/* guiledec.swg ends here */

#ifndef SWIG_NOINCLUDE
/* SWIG pointer structure */

#ifdef __cplusplus
extern "C" {
#endif

struct SwigCast {
  unsigned short      type;		  /* Index into SwigPtrTbl          */
  void               *(*cast)(void *);    /* Pointer casting function       */
  struct SwigCast    *next;		  /* Linked list pointer            */
};

struct SwigPtrType {
  const char         *name;               /* Datatype name                  */
  const char	     *prettyname;         /* Pretty datatype name           */
  unsigned short      tag;		  /* Index in SwigPtrTable          */
  struct SwigCast    *cast;		  /* List of compatible types       */
};

/* Some variables  */

static int SwigPtrMax  = 64;            /* Max entries that can be held */
                                        /* (may be adjusted dynamically) */
static int SwigPtrN    = 0;             /* Current number of entries */
static int SwigPtrSort = 0;             /* Status flag indicating sort */

/* Pointer table */
static SwigPtrType *SwigPtrList = 0;    /* Table containing types and
					   equivalences; items will only
                                           be appended */
static size_t *SwigPtrTbl = 0;          /* Sorted indirect table; items will
					   be inserted */

/* Sort comparison function */
static int
swigsort (const void *data1, const void *data2)
{
  size_t index1 = * (size_t *) data1;
  size_t index2 = * (size_t *) data2;
  return strcmp(SwigPtrList[index1].name, SwigPtrList[index2].name);
}

/* Register a new datatype with the type-checker */
SWIGSTATIC size_t
SWIG_RegisterType (const char *type, const char *prettyname)
{
  int i;

  /* Allocate the pointer table if necessary */
  if (!SwigPtrList) {
    SwigPtrList = (SwigPtrType *) malloc(SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrTbl = (size_t *) malloc(SwigPtrMax*sizeof(size_t));
    SwigPtrN = 0;
  }
  /* Grow the table if necessary */
  if (SwigPtrN >= SwigPtrMax) {
    SwigPtrMax = 2*SwigPtrMax;
    SwigPtrList = (SwigPtrType *) realloc((char *) SwigPtrList,
					  SwigPtrMax*sizeof(SwigPtrType));
    SwigPtrTbl = (size_t *) realloc((char *) SwigPtrTbl,
				    SwigPtrMax*sizeof(size_t));
  }
  /* Look up type */
  for (i = 0; i < SwigPtrN; i++)
    if (strcmp(SwigPtrList[i].name,type) == 0) {
      if (prettyname!=NULL)
	SwigPtrList[i].prettyname = prettyname;
      return i;
    }
  {
    struct SwigPtrType *t;
    size_t tag;
#if 0
    fprintf(stderr, "New type: %s\n", type);
#endif
    tag = SwigPtrTbl[SwigPtrN] = SwigPtrN;
    t = &SwigPtrList[tag];
    t->name = type;
    t->prettyname = prettyname;
    t->tag = SwigPtrN;
    t->cast = NULL;
    SwigPtrN++;
    SwigPtrSort = 0; 
    return tag;
  }
}

/* Register two data types and their mapping with the type checker. */
SWIGSTATIC void
SWIG_RegisterMapping (const char *origtype, const char *newtype,
		      swig_converter_func cast)
{
  size_t t = SWIG_RegisterType(origtype, NULL);

  if (newtype!=NULL) {
    size_t t1 = SWIG_RegisterType(newtype, NULL);
    struct SwigCast *c;
    /* Check for existing cast */
    for (c = SwigPtrList[t].cast; c && c->type!=t1; c=c->next) /* nothing */;
    if (c) {
      if (cast) c->cast = cast;
    }
    else {
      c = (struct SwigCast *) malloc(sizeof(struct SwigCast));
      c->type = t1;
      c->cast = cast;
      c->next = SwigPtrList[t].cast;
      SwigPtrList[t].cast = c;
    }
  }
}

/* Sort table */

static void
SWIG_SortTable (void)
{
  qsort ((void *) SwigPtrTbl, SwigPtrN, sizeof(size_t), swigsort);
  /* Indicate that everything is sorted */
  SwigPtrSort = 1;
}

/* Look up pointer-type entry in table */

static int
swigcmp (const void *key, const void *data)
{
  char *k = (char *) key;
  size_t index = *(size_t *)data;
  return strcmp(k, SwigPtrList[index].name);
}

static SwigPtrType *
SWIG_GetPtrType (const char *_t)
{
  size_t *result;
  if (!SwigPtrSort) SWIG_SortTable();
  result = (size_t *) bsearch(_t, SwigPtrTbl, SwigPtrN, sizeof(size_t), swigcmp);
  if (result!=NULL) return SwigPtrList+*result;
  else return NULL;
}

/* Cast a pointer if possible; returns 1 if successful */

static int
SWIG_Cast (void *source, size_t source_type,
	   void **ptr, size_t dest_type)
{
  if (dest_type != source_type) {
    /* We have a type mismatch.  Will have to look through our type
       mapping table to figure out whether or not we can accept this
       datatype.  */
    struct SwigCast *c;
    for (c = SwigPtrList[dest_type].cast;
	 c && c->type!=source_type; c = c->next) /* nothing */;
    if (c) {
      /* Get pointer value. */
      if (c->cast) *ptr = (*(c->cast))(source);
      else *ptr = source;
      return 1;
    }
    /* Didn't find any sort of match for this data.
       Get the pointer value and return false.  */
    *ptr = source;
    return 0;
  } else {
    /* Found a match on the first try.  Return pointer value.  */
    *ptr = source;
    return 1;
  }
}

/* Dynamic pointer casting. Down an inheritance hierarchy */
SWIGSTATIC swig_type_info * 
SWIG_TypeDynamicCast(swig_type_info *ty, void **ptr) 
{
  swig_type_info *lastty = ty;
  if (!ty || !ty->dcast) return ty;
  while (ty && (ty->dcast)) {
     ty = (*ty->dcast)(ptr);
     if (ty) lastty = ty;
  }
  return lastty;
}

/* Function for getting a pointer value */

static unsigned long swig_tag = 0;

SWIGSTATIC SCM
SWIG_Guile_MakePtr (void *ptr, swig_type_info *type)
{
  if (ptr==NULL) return SCM_EOL;
  SCM_RETURN_NEWSMOB((((unsigned long)type->tag << 16) | swig_tag),
		     ptr);
}

/* Return 0 if successful. */
SWIGSTATIC int
SWIG_Guile_GetPtr(SCM s, void **result, swig_type_info *type)
{
  if (SCM_NULLP(s)) {
    *result = NULL;
    return 0;
  }
  else if (SCM_NIMP(s)
	   && (unsigned long) SCM_TYP16(s) == swig_tag) {
    if (type) 
      return !SWIG_Cast((void *) SCM_CDR(s),
			(long) SCM_CAR(s) >> 16,
			result, type->tag);
    else {
      *result = (void *) SCM_CDR(s);
      return 0;
    }
  }
  return 1;
}

SWIGSTATIC void *
SWIG_Guile_MustGetPtr (SCM s, swig_type_info *type,
		       int argnum, const char *func_name)
{
  void *result;
  if (SWIG_Guile_GetPtr(s, &result, type)) {
    /* type mismatch */
    scm_wrong_type_arg((char *) func_name, argnum, s);
  }
  return result;
}

/* Init */

static int
print_swig (SCM swig_smob, SCM port, scm_print_state *pstate)
{
  scm_puts((char *) "#<swig ", port);
  if (SwigPtrList[(long) SCM_CAR(swig_smob) >> 16].prettyname != NULL)
    scm_puts((char*) SwigPtrList[(long) SCM_CAR(swig_smob) >> 16].prettyname, port);
  else scm_puts((char*) SwigPtrList[(long) SCM_CAR(swig_smob) >> 16].name, port);
  scm_puts((char *) " ", port);
  scm_intprint((long) SCM_CDR(swig_smob), 16, port);
  scm_puts((char *) ">", port);
  /* non-zero means success */
  return 1;
}

static SCM
equalp_swig (SCM A, SCM B)
{
  if (SCM_CAR(A) == SCM_CAR(B)
      && SCM_CDR(A) == SCM_CDR(B))
    return SCM_BOOL_T;
  else return SCM_BOOL_F;
}

SWIGSTATIC void
SWIG_Guile_Init (void)
{
  if (swig_tag == 0) {
    swig_tag = scm_make_smob_type_mfpe((char *) "swig", 0, NULL, NULL,
				       print_swig, equalp_swig);
  }
}

/* Convert datatype table */

SWIGSTATIC
void SWIG_Guile_RegisterTypes(swig_type_info **table,
			      swig_type_info **init)
{
  for (; *init; table++, init++) {
    swig_type_info *type = *table = *init;
    const char *origname = type->name;
    /* Register datatype itself and store pointer back */
    type->tag = SWIG_RegisterType(origname, type->str);
    /* Register compatible types */
    for (type++; type->name; type++)
      SWIG_RegisterMapping(origname, type->name, type->converter);
  }    
}

SWIGSTATIC int
SWIG_Guile_GetArgs (SCM *dest, SCM rest,
		    int reqargs, int optargs,
		    const char *procname)
{
  int i;
  int num_args_passed = 0;
  for (i = 0; i<reqargs; i++) {
    if (!SCM_CONSP(rest))
      scm_wrong_num_args(gh_str02scm((char *) procname));
    *dest++ = SCM_CAR(rest);
    rest = SCM_CDR(rest);
    num_args_passed++;
  }
  for (i = 0; i<optargs && SCM_CONSP(rest); i++) {
    *dest++ = SCM_CAR(rest);
    rest = SCM_CDR(rest);
    num_args_passed++;
  }
  for (; i<optargs; i++)
    *dest++ = GH_NOT_PASSED;
  if (!SCM_NULLP(rest))
    scm_wrong_num_args(gh_str02scm((char *) procname));
  return num_args_passed;
}

#ifdef __cplusplus
}
#endif

/* guile.swg ends here */

#endif


/* -------- TYPES TABLE (BEGIN) -------- */

#define  SWIGTYPE_p_QStringList swig_types[0] 
#define  SWIGTYPE_p_MainChatPage swig_types[1] 
#define  SWIGTYPE_p_Page swig_types[2] 
#define  SWIGTYPE_p_MainWin swig_types[3] 
#define  SWIGTYPE_p_QMtp swig_types[4] 
#define  SWIGTYPE_p_ChatSession swig_types[5] 
#define  SWIGTYPE_p_QWidget swig_types[6] 
static swig_type_info *swig_types[8];

/* -------- TYPES TABLE (END) -------- */


#define  SWIG_MemoryError    1
#define  SWIG_IOError        2
#define  SWIG_RuntimeError   3
#define  SWIG_IndexError     4
#define  SWIG_TypeError      5
#define  SWIG_DivisionByZero 6
#define  SWIG_OverflowError  7
#define  SWIG_SyntaxError    8
#define  SWIG_ValueError     9
#define  SWIG_SystemError   10
#define  SWIG_UnknownError  99


  static void SWIG_exception_ (int code, const char *msg,
                               const char *subr) {
#define ERROR(scmerr)					\
	scm_error(gh_symbol2scm((char *) (scmerr)),	\
		  (char *) subr, (char *) msg,		\
		  SCM_EOL, SCM_BOOL_F)
#define MAP(swigerr, scmerr)			\
	case swigerr:				\
	  ERROR(scmerr);			\
	  break
    switch (code) {
      MAP(SWIG_MemoryError,	"swig-memory-error");
      MAP(SWIG_IOError,		"swig-io-error");
      MAP(SWIG_RuntimeError,	"swig-runtime-error");
      MAP(SWIG_IndexError,	"swig-index-error");
      MAP(SWIG_TypeError,	"swig-type-error");
      MAP(SWIG_DivisionByZero,	"swig-division-by-zero");
      MAP(SWIG_OverflowError,	"swig-overflow-error");
      MAP(SWIG_SyntaxError,	"swig-syntax-error");
      MAP(SWIG_ValueError,	"swig-value-error");
      MAP(SWIG_SystemError,	"swig-system-error");
    default:
      ERROR("swig-error");
    }
#undef ERROR
#undef MAP
  }

#define SWIG_exception(a,b) SWIG_exception_(a, b, FUNC_NAME)


#include <string>


#include "qnet.h"


#include "mainwin.h"

extern MainWin *main_window;

#include "ChatSession.h"

static SCM
_wrap_qnet_load_config_file (SCM s_0)
{
#define FUNC_NAME "qnet-load-config-file"
    QMtp *arg1 = (QMtp *) 0 ;
    bool result;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    result = (bool)(arg1)->loadConfigFile();
    
    gh_allow_ints();
    {
        gswig_result = gh_bool2scm(result);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_save_config_file (SCM s_0)
{
#define FUNC_NAME "qnet-save-config-file"
    QMtp *arg1 = (QMtp *) 0 ;
    bool result;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    result = (bool)(arg1)->saveConfigFile();
    
    gh_allow_ints();
    {
        gswig_result = gh_bool2scm(result);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_get_new_page (SCM s_0, SCM s_1, SCM s_2, SCM s_3, SCM s_4)
{
#define FUNC_NAME "qnet-get-new-page"
    QMtp *arg1 = (QMtp *) 0 ;
    QString *arg2 = 0 ;
    QString *arg3 = 0 ;
    ChatSession *arg4 = (ChatSession *) 0 ;
    bool arg5 = (bool) true ;
    Page *result;
    QString temp2 ;
    char *tempptr2 ;
    QString temp3 ;
    char *tempptr3 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    {
        if (gh_string_p(s_1)) {
            tempptr2 = SWIG_scm2str(s_1);
            temp2 = QString(tempptr2);
            if (tempptr2) SWIG_free(tempptr2);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    {
        if (gh_string_p(s_2)) {
            tempptr3 = SWIG_scm2str(s_2);
            temp3 = QString(tempptr3);
            if (tempptr3) SWIG_free(tempptr3);
            arg3 = &temp3;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    {
        arg4 = (ChatSession *)SWIG_MustGetPtr(s_3, SWIGTYPE_p_ChatSession, 4, 0);
    }
    if (s_4 != SCM_UNDEFINED) {
        {
            arg5 = gh_scm2bool(s_4);
        }
    }
    gh_defer_ints();
    result = (Page *)(arg1)->getNewPage((QString const &)*arg2,(QString const &)*arg3,arg4,arg5);
    
    gh_allow_ints();
    {
        gswig_result = SWIG_NewPointerObj (result, SWIGTYPE_p_Page, 0);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_configure (SCM s_0)
{
#define FUNC_NAME "qnet-configure"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    (arg1)->slotConfigure();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_store_config (SCM s_0)
{
#define FUNC_NAME "qnet-store-config"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    (arg1)->slotStoreConfig();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_open (SCM s_0)
{
#define FUNC_NAME "qnet-open"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    (arg1)->fileNew();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_save (SCM s_0)
{
#define FUNC_NAME "qnet-save"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    (arg1)->fileSaveAs();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_exit (SCM s_0)
{
#define FUNC_NAME "qnet-exit"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    (arg1)->fileExit();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_close_current_tab (SCM s_0)
{
#define FUNC_NAME "qnet-close-current-tab"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    (arg1)->closeCurrentTab();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_close_tab (SCM s_0, SCM s_1)
{
#define FUNC_NAME "qnet-close-tab"
    QMtp *arg1 = (QMtp *) 0 ;
    QWidget *arg2 = (QWidget *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    {
        arg2 = (QWidget *)SWIG_MustGetPtr(s_1, SWIGTYPE_p_QWidget, 2, 0);
    }
    gh_defer_ints();
    (arg1)->closeTab(arg2);
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_load_plugin (SCM s_0, SCM s_1)
{
#define FUNC_NAME "qnet-load-plugin"
    QMtp *arg1 = (QMtp *) 0 ;
    QString *arg2 = 0 ;
    bool result;
    QString temp2 ;
    char *tempptr2 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    {
        if (gh_string_p(s_1)) {
            tempptr2 = SWIG_scm2str(s_1);
            temp2 = QString(tempptr2);
            if (tempptr2) SWIG_free(tempptr2);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    gh_defer_ints();
    result = (bool)(arg1)->loadPlugin((QString const &)*arg2);
    
    gh_allow_ints();
    {
        gswig_result = gh_bool2scm(result);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_unload_plugin (SCM s_0, SCM s_1)
{
#define FUNC_NAME "qnet-unload-plugin"
    QMtp *arg1 = (QMtp *) 0 ;
    QString *arg2 = 0 ;
    bool result;
    QString temp2 ;
    char *tempptr2 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    {
        if (gh_string_p(s_1)) {
            tempptr2 = SWIG_scm2str(s_1);
            temp2 = QString(tempptr2);
            if (tempptr2) SWIG_free(tempptr2);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    gh_defer_ints();
    result = (bool)(arg1)->unloadPlugin((QString const &)*arg2);
    
    gh_allow_ints();
    {
        gswig_result = gh_bool2scm(result);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_refresh_menu (SCM s_0)
{
#define FUNC_NAME "qnet-refresh-menu"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    (arg1)->refreshMenu();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_load_stylesheet (SCM s_0)
{
#define FUNC_NAME "qnet-load-stylesheet"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    (arg1)->loadStyleSheet();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_launch_session (SCM s_0, SCM s_1)
{
#define FUNC_NAME "qnet-launch-session"
    QMtp *arg1 = (QMtp *) 0 ;
    QString *arg2 = 0 ;
    QString temp2 ;
    char *tempptr2 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    {
        if (gh_string_p(s_1)) {
            tempptr2 = SWIG_scm2str(s_1);
            temp2 = QString(tempptr2);
            if (tempptr2) SWIG_free(tempptr2);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    gh_defer_ints();
    (arg1)->launchSession((QString const &)*arg2);
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_load_plugins (SCM s_0)
{
#define FUNC_NAME "qnet-load-plugins"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    (arg1)->loadPlugins();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_unload_plugins (SCM s_0)
{
#define FUNC_NAME "qnet-unload-plugins"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    (arg1)->unloadPlugins();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_reload_plugins (SCM s_0, SCM s_1)
{
#define FUNC_NAME "qnet-reload-plugins"
    QMtp *arg1 = (QMtp *) 0 ;
    QStringList *arg2 = 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    {
        arg2 = (QStringList *)SWIG_MustGetPtr(s_1, SWIGTYPE_p_QStringList, 2, 0);
    }
    gh_defer_ints();
    (arg1)->reloadPlugins((QStringList const &)*arg2);
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_sessions_number (SCM s_0)
{
#define FUNC_NAME "qnet-sessions-number"
    QMtp *arg1 = (QMtp *) 0 ;
    int result;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    result = (int)(arg1)->sessionsNumber();
    
    gh_allow_ints();
    {
        gswig_result = gh_int2scm(result);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_qnet_session (SCM s_0, SCM s_1)
{
#define FUNC_NAME "qnet-session"
    QMtp *arg1 = (QMtp *) 0 ;
    int arg2 ;
    ChatSession *result;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    {
        arg2 = gh_scm2int(s_1);
    }
    gh_defer_ints();
    result = (ChatSession *)(arg1)->session(arg2);
    
    gh_allow_ints();
    {
        gswig_result = SWIG_NewPointerObj (result, SWIGTYPE_p_ChatSession, 0);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_new_qnet ()
{
#define FUNC_NAME "new-qnet"
    QMtp *result;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    gh_defer_ints();
    result = (QMtp *)new QMtp();
    
    gh_allow_ints();
    {
        gswig_result = SWIG_NewPointerObj (result, SWIGTYPE_p_QMtp, 1);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_delete_qnet (SCM s_0)
{
#define FUNC_NAME "delete-qnet"
    QMtp *arg1 = (QMtp *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (QMtp *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_QMtp, 1, 0);
    }
    gh_defer_ints();
    delete arg1;
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_mainwin_set_use_dock (SCM s_0)
{
#define FUNC_NAME "mainwin-set-use-dock"
    MainWin *arg1 = (MainWin *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (MainWin *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_MainWin, 1, 0);
    }
    gh_defer_ints();
    (arg1)->setUseDock();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_mainwin_qmtp (SCM s_0)
{
#define FUNC_NAME "mainwin-qmtp"
    MainWin *arg1 = (MainWin *) 0 ;
    QMtp *result;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (MainWin *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_MainWin, 1, 0);
    }
    gh_defer_ints();
    result = (QMtp *)(arg1)->qmtp();
    
    gh_allow_ints();
    {
        gswig_result = SWIG_NewPointerObj (result, SWIGTYPE_p_QMtp, 0);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_main_window(SCM s_0)
{
#define FUNC_NAME "main-window"
    SCM gswig_result;
    
    if (s_0 != SCM_UNDEFINED) {
        {
            main_window = (MainWin *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_MainWin, 1, 0);
        }
    }
    {
        gswig_result = SWIG_NewPointerObj (main_window, SWIGTYPE_p_MainWin, 0);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_display_err (SCM s_0, SCM s_1)
{
#define FUNC_NAME "chatsession-display-err"
    ChatSession *arg1 = (ChatSession *) 0 ;
    QString *arg2 = 0 ;
    QString temp2 ;
    char *tempptr2 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    {
        if (gh_string_p(s_1)) {
            tempptr2 = SWIG_scm2str(s_1);
            temp2 = QString(tempptr2);
            if (tempptr2) SWIG_free(tempptr2);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    gh_defer_ints();
    (arg1)->displayStderr((QString const &)*arg2);
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_display_out (SCM s_0, SCM s_1)
{
#define FUNC_NAME "chatsession-display-out"
    ChatSession *arg1 = (ChatSession *) 0 ;
    QString *arg2 = 0 ;
    QString temp2 ;
    char *tempptr2 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    {
        if (gh_string_p(s_1)) {
            tempptr2 = SWIG_scm2str(s_1);
            temp2 = QString(tempptr2);
            if (tempptr2) SWIG_free(tempptr2);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    gh_defer_ints();
    (arg1)->displayStdout((QString const &)*arg2);
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_session_name (SCM s_0)
{
#define FUNC_NAME "chatsession-session-name"
    ChatSession *arg1 = (ChatSession *) 0 ;
    QString *result;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    gh_defer_ints();
    {
        QString const &_result_ref = ((ChatSession const *)arg1)->sessionName();
        result = (QString *) &_result_ref;
    }
    
    gh_allow_ints();
    {
        //    gswig_result = gh_str02scm(((std::string)(*result)).c_str());
        gswig_result = gh_str02scm((result)->ascii());
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_update_filters (SCM s_0)
{
#define FUNC_NAME "chatsession-update-filters"
    ChatSession *arg1 = (ChatSession *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    gh_defer_ints();
    (arg1)->updateFilters();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_chatpage (SCM s_0)
{
#define FUNC_NAME "chatsession-chatpage"
    ChatSession *arg1 = (ChatSession *) 0 ;
    MainChatPage *result;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    gh_defer_ints();
    result = (MainChatPage *)(arg1)->chatpage();
    
    gh_allow_ints();
    {
        gswig_result = SWIG_NewPointerObj (result, SWIGTYPE_p_MainChatPage, 0);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_logged_p (SCM s_0)
{
#define FUNC_NAME "chatsession-logged-p"
    ChatSession *arg1 = (ChatSession *) 0 ;
    bool result;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    gh_defer_ints();
    result = (bool)(arg1)->isLogged();
    
    gh_allow_ints();
    {
        gswig_result = gh_bool2scm(result);
    }
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_close_session (SCM s_0)
{
#define FUNC_NAME "chatsession-close-session"
    ChatSession *arg1 = (ChatSession *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    gh_defer_ints();
    (arg1)->closeSession();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_link_clicked (SCM s_0, SCM s_1)
{
#define FUNC_NAME "chatsession-link-clicked"
    ChatSession *arg1 = (ChatSession *) 0 ;
    QString *arg2 = 0 ;
    QString temp2 ;
    char *tempptr2 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    {
        if (gh_string_p(s_1)) {
            tempptr2 = SWIG_scm2str(s_1);
            temp2 = QString(tempptr2);
            if (tempptr2) SWIG_free(tempptr2);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    gh_defer_ints();
    (arg1)->slotLinkClicked((QString const &)*arg2);
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_reconnect (SCM s_0)
{
#define FUNC_NAME "chatsession-reconnect"
    ChatSession *arg1 = (ChatSession *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    gh_defer_ints();
    (arg1)->slotReconnect();
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_kill (SCM s_0, SCM s_1)
{
#define FUNC_NAME "chatsession-kill"
    ChatSession *arg1 = (ChatSession *) 0 ;
    Page *arg2 = (Page *) 0 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    {
        arg2 = (Page *)SWIG_MustGetPtr(s_1, SWIGTYPE_p_Page, 2, 0);
    }
    gh_defer_ints();
    (arg1)->kill(arg2);
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_send (SCM s_0, SCM s_1)
{
#define FUNC_NAME "chatsession-send"
    ChatSession *arg1 = (ChatSession *) 0 ;
    QString *arg2 = 0 ;
    QString temp2 ;
    char *tempptr2 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    {
        if (gh_string_p(s_1)) {
            tempptr2 = SWIG_scm2str(s_1);
            temp2 = QString(tempptr2);
            if (tempptr2) SWIG_free(tempptr2);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    gh_defer_ints();
    (arg1)->send((QString const &)*arg2);
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_incoming (SCM s_0, SCM s_1)
{
#define FUNC_NAME "chatsession-incoming"
    ChatSession *arg1 = (ChatSession *) 0 ;
    QString *arg2 = 0 ;
    QString temp2 ;
    char *tempptr2 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    {
        if (gh_string_p(s_1)) {
            tempptr2 = SWIG_scm2str(s_1);
            temp2 = QString(tempptr2);
            if (tempptr2) SWIG_free(tempptr2);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    gh_defer_ints();
    (arg1)->incoming((QString const &)*arg2);
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


static SCM
_wrap_chatsession_outgoing (SCM s_0, SCM s_1)
{
#define FUNC_NAME "chatsession-outgoing"
    ChatSession *arg1 = (ChatSession *) 0 ;
    QString *arg2 = 0 ;
    QString temp2 ;
    char *tempptr2 ;
    SCM gswig_result;
    int gswig_list_p = 0;
    
    {
        arg1 = (ChatSession *)SWIG_MustGetPtr(s_0, SWIGTYPE_p_ChatSession, 1, 0);
    }
    {
        if (gh_string_p(s_1)) {
            tempptr2 = SWIG_scm2str(s_1);
            temp2 = QString(tempptr2);
            if (tempptr2) SWIG_free(tempptr2);
            arg2 = &temp2;
        } else {
            SWIG_exception(SWIG_TypeError, "string expected");
        }
    }
    gh_defer_ints();
    (arg1)->outgoing((QString const &)*arg2);
    
    gh_allow_ints();
    gswig_result = SCM_UNSPECIFIED;
    
    return gswig_result;
#undef FUNC_NAME
}


#ifdef __cplusplus
extern "C" {
#endif

/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (BEGIN) -------- */

static swig_type_info _swigt__p_QStringList[] = {{"_p_QStringList", 0, "QStringList *", 0},{"_p_QStringList"},{0}};
static swig_type_info _swigt__p_MainChatPage[] = {{"_p_MainChatPage", 0, "MainChatPage *", 0},{"_p_MainChatPage"},{0}};
static swig_type_info _swigt__p_Page[] = {{"_p_Page", 0, "Page *", 0},{"_p_Page"},{0}};
static swig_type_info _swigt__p_MainWin[] = {{"_p_MainWin", 0, "MainWin *", 0},{"_p_MainWin"},{0}};
static swig_type_info _swigt__p_QMtp[] = {{"_p_QMtp", 0, "QMtp *", 0},{"_p_QMtp"},{0}};
static swig_type_info _swigt__p_ChatSession[] = {{"_p_ChatSession", 0, "ChatSession *", 0},{"_p_ChatSession"},{0}};
static swig_type_info _swigt__p_QWidget[] = {{"_p_QWidget", 0, "QWidget *", 0},{"_p_QWidget"},{0}};

static swig_type_info *swig_types_initial[] = {
_swigt__p_QStringList, 
_swigt__p_MainChatPage, 
_swigt__p_Page, 
_swigt__p_MainWin, 
_swigt__p_QMtp, 
_swigt__p_ChatSession, 
_swigt__p_QWidget, 
0
};


/* -------- TYPE CONVERSION AND EQUIVALENCE RULES (END) -------- */

extern void
SWIG_init (void)
{
    static int _swig_init = 0;
    
    if (!_swig_init) {
        SWIG_Guile_RegisterTypes(swig_types, swig_types_initial);
        _swig_init = 1;
    }
    
    SWIG_Guile_Init();
    
    gh_new_procedure("qnet-load-config-file", (swig_guile_proc) _wrap_qnet_load_config_file, 1, 0, 0);
    gh_new_procedure("qnet-save-config-file", (swig_guile_proc) _wrap_qnet_save_config_file, 1, 0, 0);
    gh_new_procedure("qnet-get-new-page", (swig_guile_proc) _wrap_qnet_get_new_page, 4, 1, 0);
    gh_new_procedure("qnet-configure", (swig_guile_proc) _wrap_qnet_configure, 1, 0, 0);
    gh_new_procedure("qnet-store-config", (swig_guile_proc) _wrap_qnet_store_config, 1, 0, 0);
    gh_new_procedure("qnet-open", (swig_guile_proc) _wrap_qnet_open, 1, 0, 0);
    gh_new_procedure("qnet-save", (swig_guile_proc) _wrap_qnet_save, 1, 0, 0);
    gh_new_procedure("qnet-exit", (swig_guile_proc) _wrap_qnet_exit, 1, 0, 0);
    gh_new_procedure("qnet-close-current-tab", (swig_guile_proc) _wrap_qnet_close_current_tab, 1, 0, 0);
    gh_new_procedure("qnet-close-tab", (swig_guile_proc) _wrap_qnet_close_tab, 2, 0, 0);
    gh_new_procedure("qnet-load-plugin", (swig_guile_proc) _wrap_qnet_load_plugin, 2, 0, 0);
    gh_new_procedure("qnet-unload-plugin", (swig_guile_proc) _wrap_qnet_unload_plugin, 2, 0, 0);
    gh_new_procedure("qnet-refresh-menu", (swig_guile_proc) _wrap_qnet_refresh_menu, 1, 0, 0);
    gh_new_procedure("qnet-load-stylesheet", (swig_guile_proc) _wrap_qnet_load_stylesheet, 1, 0, 0);
    gh_new_procedure("qnet-launch-session", (swig_guile_proc) _wrap_qnet_launch_session, 2, 0, 0);
    gh_new_procedure("qnet-load-plugins", (swig_guile_proc) _wrap_qnet_load_plugins, 1, 0, 0);
    gh_new_procedure("qnet-unload-plugins", (swig_guile_proc) _wrap_qnet_unload_plugins, 1, 0, 0);
    gh_new_procedure("qnet-reload-plugins", (swig_guile_proc) _wrap_qnet_reload_plugins, 2, 0, 0);
    gh_new_procedure("qnet-sessions-number", (swig_guile_proc) _wrap_qnet_sessions_number, 1, 0, 0);
    gh_new_procedure("qnet-session", (swig_guile_proc) _wrap_qnet_session, 2, 0, 0);
    gh_new_procedure("new-qnet", (swig_guile_proc) _wrap_new_qnet, 0, 0, 0);
    gh_new_procedure("delete-qnet", (swig_guile_proc) _wrap_delete_qnet, 1, 0, 0);
    gh_new_procedure("mainwin-set-use-dock", (swig_guile_proc) _wrap_mainwin_set_use_dock, 1, 0, 0);
    gh_new_procedure("mainwin-qmtp", (swig_guile_proc) _wrap_mainwin_qmtp, 1, 0, 0);
    gh_new_procedure("main-window", (swig_guile_proc) _wrap_main_window, 0, 1, 0);
    gh_new_procedure("chatsession-display-err", (swig_guile_proc) _wrap_chatsession_display_err, 2, 0, 0);
    gh_new_procedure("chatsession-display-out", (swig_guile_proc) _wrap_chatsession_display_out, 2, 0, 0);
    gh_new_procedure("chatsession-session-name", (swig_guile_proc) _wrap_chatsession_session_name, 1, 0, 0);
    gh_new_procedure("chatsession-update-filters", (swig_guile_proc) _wrap_chatsession_update_filters, 1, 0, 0);
    gh_new_procedure("chatsession-chatpage", (swig_guile_proc) _wrap_chatsession_chatpage, 1, 0, 0);
    gh_new_procedure("chatsession-logged-p", (swig_guile_proc) _wrap_chatsession_logged_p, 1, 0, 0);
    gh_new_procedure("chatsession-close-session", (swig_guile_proc) _wrap_chatsession_close_session, 1, 0, 0);
    gh_new_procedure("chatsession-link-clicked", (swig_guile_proc) _wrap_chatsession_link_clicked, 2, 0, 0);
    gh_new_procedure("chatsession-reconnect", (swig_guile_proc) _wrap_chatsession_reconnect, 1, 0, 0);
    gh_new_procedure("chatsession-kill", (swig_guile_proc) _wrap_chatsession_kill, 2, 0, 0);
    gh_new_procedure("chatsession-send", (swig_guile_proc) _wrap_chatsession_send, 2, 0, 0);
    gh_new_procedure("chatsession-incoming", (swig_guile_proc) _wrap_chatsession_incoming, 2, 0, 0);
    gh_new_procedure("chatsession-outgoing", (swig_guile_proc) _wrap_chatsession_outgoing, 2, 0, 0);
}

#ifdef __cplusplus
}
#endif
extern "C" {
/* Linkage: simple */

}

